Our development journey went very smoothly, and we can attribute that to each of our group members' efforts and commitment to the project throughout the entirety of our time working. Our group met every week, beginning the week after the creation of our UML State Diagram, and we discussed what to work on next, dividing the work properly among members. We first addressed our test suite, implementing each of the fifteen tests listed in our in-class exercise. In our second meeting, we divided much of the required work for the rest of the project. Each of our group members, having completed their assigned tests, began to work on their assigned features. After our third meeting, many of the features had begun to be fully implemented, so much of the focus for the latter half of the project cycle was ensuring that our new code was working properly. Our frequent meetings helped us to catch which changes we made that affected other members' code, especially since the alteration of the preexisting stopwatch code caused issues, but all of which were ultimately resolved due to our groupâ€™s superior communication. In our fourth meeting, we finished up some of the last, less consequential features of the project, such as minor changes to the UI and adding the alarm sound, each of which were not detrimental to the rest of the code before their completion. Our last meeting after our last class, we went through the assignment sheet once again and reviewed which requirements were completed. This review was necessary, as it allowed us to find some of the smaller requirements that we missed. 
Our extended UML state diagram mapped directly to the model we used for the project.  The original repository had laprunning and stopped states that we refactored into incrementing and alarming states. Then we adjusted the running state to handle ticking down the time on the timer instead of incrementing it.  We also added classes to model the behaviour of the bounded container from the click counter project to handle the logic of the incrementing state. We had some difficulty with implementing the waiting time in the incrementing state, and went through a few iterations.  Eventually we settled on adding a variable and methods to the state machine to manipulate the waiting time inside of the incrementing state while also being able to properly reset the wait time when transitioning from stopped states back to incrementing states. In our process, we found that it was more important for us to model first. Having our UML state diagram gave us a much better understanding of class interaction and showed us clearly what tests we should make. The second week of our in-class exercise, we were able to make fifteen different tests to test various parts of the timer, this would not have gone so smoothly without modeling first.
